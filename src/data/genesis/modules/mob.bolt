from beet import Equipment, Texture, Model, ItemModel, Function, SoundConfig
from PIL import Image

def register_sounds(key, sounds):
    ctx.assets["genesis"].sound_config.merge(SoundConfig({
        key: {
            "sounds": sounds,
            "subtitle": f"genesis.{key}"
        }
    }))

append function genesis:tick:
    function genesis:mob/tick

append function genesis:load:
    function genesis:mob/load

class classproperty:
    def __init__(self, func):
        self.fget = func
    def __get__(self, instance, owner):
        return self.fget(owner)

def modifies_entity_data(func):
    func.modifies_entity_data = True
    return func

def uses_entity_data(func):
    func.uses_entity_data = True
    return func

def before_all(func):
    func.before_all = True
    return func

def after_all(func):
    func.after_all = True
    return func

def genesis_mob(cls: type):
    cls.id = camel_case_to_snake_case(cls.__name__)
    cls.namespace = cls.__module__.split(":")[0]
    cls.init_vanilla_components(cls)
    components, callables = _get_components_and_callables_from_parents(cls)
    _run_callables(cls, callables["before_all"])
    _run_callables(cls, callables["regular"])
    for k, v in components.items(): 
        if k not in vanilla_components:
            component = CustomComponents.__dict__[k]
            component(cls, v)
    _run_callables(cls, callables["after_all"])

    return cls


class GenesisMob:
    def init_vanilla_components(cls):
        cls.tags = set()
        cls.equipment = dict()
        cls.drop_chances = dict()
        cls.attributes = []
        cls.active_effects = []
        cls.enchantments = dict()

    @after_all
    def generate_summon_command(mob):
        function f"{mob.namespace}:mob/summon/{mob.id}":
            summon mob.base_entity ~ ~ ~ mob.entity_data
    
    @classproperty
    def entity_data(cls):
        cls.tags.add("genesis.mob")
        cls.tags.add(f"genesis.mob.{cls.id}")
        data = {}
        components, _ = _get_components_and_callables_from_parents(cls)
        for k, v in components.items(): 
            if k in vanilla_components:
                component = VanillaComponents.__dict__[k]
                serialised = component(cls, v)
                if serialised is not None:
                    nk, nv = serialised
                    data[nk] = nv
        
        if len(cls.enchantments) > 0:
            data["equipment"]["head"]["components"].update({
                "enchantment_glint_override": False,
                "enchantments": cls.enchantments
            })
        return data


class TexturedHumanoid(GenesisMob):
    """
    A humanoid shaped mob which can wear armour. 
    Renders a custom texture by equipped items.
    """

    hurt_detection = {}
    hurt_tint = {}
    lefthand_extra_item_model = None
    righthand_extra_item_model = None

    def generate_assets(mob):
        texture_id = f"{mob.namespace}:entity/{mob.id}"
        if texture_id not in ctx.assets.textures:
            raise LookupError(f"Missing texture: {texture_id}")
        
        # pants texture & model
        img = ctx.assets.textures[texture_id].image
        img = img.crop((0,0,img.width, img.height//2))
        ctx.assets[f"{mob.namespace}:entity/equipment/humanoid_leggings/_mob/{mob.id}"] = Texture(img)
        ctx.assets[f"{mob.namespace}:_mob/{mob.id}"] = Equipment({
            "layers": {
                "humanoid_leggings": [
                    {
                        "texture": f"{mob.namespace}:_mob/{mob.id}",
                        "dyeable": {
                            "color_when_undyed": 16383998
                        }
                    }
                ]
            }
        })
        
        # arms and head models
        ctx.assets.textures[f"{mob.namespace}:item/_mob/{mob.id}"] = ctx.assets.textures[texture_id]
        for side in ["left","right"]:
            ctx.assets[f"{mob.namespace}:item/_mob/{mob.id}/{side}_arm"] = Model({
                "parent": f"{mob.namespace}:item/_mob/textured_zombie_variant/{side}_arm",
                "textures": {
                    "0": f"{mob.namespace}:item/_mob/{mob.id}"
                }
            })
        ctx.assets[f"{mob.namespace}:item/_mob/{mob.id}/head"] = Model({
            "parent": f"{mob.namespace}:item/_mob/textured_zombie_variant/head",
            "textures": {
                "0": f"{mob.namespace}:item/_mob/{mob.id}"
            }
        })

        righthand_model = {
                            "type": "minecraft:model",
                            "model": f"{mob.namespace}:item/_mob/{mob.id}/right_arm",
                            "tints": [
                                {
                                    "type": "minecraft:dye",
                                    "default": [1,1,1]
                                }
                            ]
                        }
        if mob.righthand_extra_item_model is not None:
            righthand_model = {
                "type": "minecraft:composite",
                "models": [
                    righthand_model,
                    mob.righthand_extra_item_model
                ]
            }

        lefthand_model = {
                            "type": "minecraft:model",
                            "model": f"{mob.namespace}:item/_mob/{mob.id}/left_arm",
                            "tints": [
                                {
                                    "type": "minecraft:dye",
                                    "default": [1,1,1]
                                }
                            ]
                        }
        if mob.lefthand_extra_item_model is not None:
            lefthand_model = {
                "type": "minecraft:composite",
                "models": [
                    lefthand_model,
                    mob.lefthand_extra_item_model
                ]
            }

        ctx.assets[f"{mob.namespace}:_mob/{mob.id}/skin"] = ItemModel({
            "model": {
                "type": "minecraft:select",
                "property": "minecraft:display_context",
                "cases": [
                    {
                        "when": "thirdperson_righthand",
                        "model": righthand_model
                    },
                    {
                        "when": "thirdperson_lefthand",
                        "model": lefthand_model
                    }
                ],
                "fallback": {
                    "type": "minecraft:model",
                    "model": f"{mob.namespace}:item/_mob/{mob.id}/head",
                    "tints": [
                        {
                            "type": "minecraft:dye",
                            "default": [1,1,1]
                        }
                    ]
                }
            }
        })
        skin_item = {
            "id": "minecraft:poisonous_potato",
            "count": 1,
            "components": {
                "minecraft:item_model": f"{mob.namespace}:_mob/{mob.id}/skin",
                "minecraft:equippable": {
                    "slot": "legs",
                    "asset_id": f"{mob.namespace}:_mob/{mob.id}"
                }
            }
        }
        mob.equipment.update({
            "mainhand": skin_item,
            "offhand": skin_item,
            "head": skin_item,
            "legs": skin_item
        })
        mob.drop_chances.update({
            "mainhand": 0,
            "offhand": 0,
            "head": 0,
            "legs": 0
        })

class TexturedZombieVariant(TexturedHumanoid):
    """
    A zombie-like mob with a custom texture rendered by equipped items.
    Can only use meelee attacks.
    """

    burn_in_daylight = True

    base_entity = "minecraft:zombie"


class PlayerLike(TexturedHumanoid):
    """
    A human-shaped mob which holds its arms down.
    Can only use meelee attacks.
    """

    base_entity = "minecraft:piglin_brute"
    invisible = True

    is_immune_to_zombification = True

    custom_sounds = {
        "hurt": "minecraft:entity.enderman.hurt",
        "death": "minecraft:entity.enderman.death",
        "ambient": "minecraft:entity.enderman.ambient"
    }


class CustomComponents:
    def hurt_detection(mob, component):
        mob.tags.add("genesis.mob.component.hurt_detection")
        mob.attributes.append({"id":"minecraft:max_absorption","base":-3.999999999999999})
        mob.active_effects.append({"id":"minecraft:absorption","duration":-1,"show_particles":False,"show_icon":False})
        mob.enchantments.update({"genesis:mob/component/hurt_detection": 1})

    def hurt_tint(mob, component):
        mob.tags.add("genesis.mob.component.hurt_tint")

    def burn_in_daylight(mob, component):
        if component:
            # mob.tags.add("genesis.mob.component.burn_in_daylight")
            mob.enchantments.update({"genesis:mob/component/burn_in_daylight": 1})

    def enchantments(mob, component):
        pass

    def invisible(mob, component):
        if component:
            mob.tags.add("genesis.mob.component.invisible")
            mob.active_effects.append({"id":"minecraft:invisibility","duration":-1,"show_particles":False,"show_icon":False})

    def custom_sounds(mob, component):
        mob.silent = True
        mob.tags.add("genesis.mob.component.custom_sounds")
        if "death" in component:
            append function genesis:mob/component/custom_sounds/death:
                execute if entity @s[tag=f"genesis.mob.{mob.id}"] run playsound component["death"] hostile @a[distance=..16] ~ ~ ~
        if "hurt" in component:
            append function genesis:mob/component/custom_sounds/hurt:
                execute if entity @s[tag=f"genesis.mob.{mob.id}"] run playsound component["hurt"] hostile @a[distance=..16] ~ ~ ~
        if "ambient" in component:
            append function genesis:mob/component/custom_sounds/ambient:
                execute if entity @s[tag=f"genesis.mob.{mob.id}"] run playsound component["ambient"] hostile @a[distance=..16] ~ ~ ~

class VanillaComponents:
    def tags(mob, component):
        if len(component) == 0:
            return None
        return ("Tags", list(component))
    
    def equipment(mob, component):
        if len(component.keys()) == 0:
            return None
        return ("equipment", component)
    
    def drop_chances(mob, component):
        if len(component.keys()) == 0:
            return None
        return ("drop_chances", component)
    
    def active_effects(mob, component):
        if len(component) == 0:
            return None
        return ("active_effects", component)
    
    def attributes(mob, component):
        if len(component) == 0:
            return None
        return ("attributes", component)
    
    def is_immune_to_zombification(mob, component):
        return ("IsImmuneToZombification", component)
    
    def silent(mob, component):
        return ("Silent", component)

vanilla_components = []
for k in VanillaComponents.__dict__.keys():
    if not k.startswith("__"):
        vanilla_components.append(k)
component_names = vanilla_components.copy()
for k in CustomComponents.__dict__.keys():
    if not k.startswith("__"):
        component_names.append(k)


def _get_components_and_callables_from_parents(cls):
    components = {}
    callables = {
        "before_all": [],
        "regular": [],
        "after_all": [],
    }
    # get info of parent classes recursively
    for parent in reversed(cls.__bases__):
        if parent != object:
            cmp, cal = _get_components_and_callables_from_parents(parent)
            for ck, cv in cmp.items():
                components[ck] = cv
            callables["before_all"] += cal["before_all"]
            callables["after_all"] += cal["after_all"]
            callables["regular"] += cal["regular"]
    # get info of this class
    for k, v in cls.__dict__.items():
        if (
            k in component_names or k in components
        ):  #! custom components are currently ignored
            components[k] = v
        if callable(v):
            if "custom_component" in v.__dict__:
                components[v.custom_component] = getattr(cls, v.custom_component, None)
            if getattr(v, "before_all", False):
                callables["before_all"].append(v)
            elif getattr(v, "after_all", False):
                callables["after_all"].append(v)
            elif not (v.__name__ == 'init_vanilla_components'):
                callables["regular"].append(v)
    return (components, callables)
    

def _run_callables(cls, callables):
    for c in callables:
        c(cls)


def camel_case_to_snake_case(name: str) -> str:
    out_id = name[0].lower()
    for c in name[1:]:
        if c.isupper():
            out_id += "_" + c.lower()
        else:
            out_id += c
    return out_id
