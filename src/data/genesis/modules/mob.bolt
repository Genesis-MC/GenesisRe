from beet import Equipment, Texture, Model, ItemModel, Function, SoundConfig, Structure
from beet.contrib.worldgen import WorldgenTemplatePool
from PIL import Image
from copy import deepcopy
from operator import itemgetter
from genesis:utils import add_translation, camel_case_to_snake_case, to_nbt
from nbtlib import String

# print(ctx.data["genesis"].structures["zombie"].data)


def _get_components_and_callables_from_parents(cls):
    components = {}
    callables = {
        "before_all": [],
        "regular": [],
        "after_all": [],
    }
    # get info of parent classes recursively
    for parent in reversed(cls.__bases__):
        if parent != object:
            cmp, cal = _get_components_and_callables_from_parents(parent)
            for ck, cv in cmp.items():
                components[ck] = cv
            callables["before_all"] += cal["before_all"]
            callables["after_all"] += cal["after_all"]
            callables["regular"] += cal["regular"]
    # get info of this class
    for k, v in cls.__dict__.items():
        if (
            k in component_names or k in components
        ):  #! custom components are currently ignored
            components[k] = v
        if callable(v):
            if "custom_component" in v.__dict__:
                components[v.custom_component] = getattr(cls, v.custom_component, None)
            if getattr(v, "before_all", False):
                callables["before_all"].append(v)
            elif getattr(v, "after_all", False):
                callables["after_all"].append(v)
            elif not (v.__name__ == 'init_vanilla_components'):
                callables["regular"].append(v)
    return (components, callables)
    

def _run_callables(cls, callables):
    for c in callables:
        c(cls)

def add_template_pool(mob: type):
    path = f"{mob.namespace}:mob/{mob.id}"
    ctx.data[path] = WorldgenTemplatePool({
        "elements": [
            {
            "element": {
                "element_type": "minecraft:single_pool_element",
                "location": path,
                "processors": {
                    "processors": []
                },
                "projection": "rigid"
            },
            "weight": 1
            }
        ],
        "fallback": "minecraft:empty"
    })


def add_structure(mob: type):
    path = f"{mob.namespace}:mob/{mob.id}"
    data = {
        "id": "minecraft:armor_stand",
        "NoGravity": True,
        "Small": True,
        "Marker": True,
        "Invisible": True,
        "Invulnerable": True,
        "equipment": {
            "feet": {
                "id": "minecraft:poisonous_potato",
                "components": {
                    "minecraft:enchantments": {"genesis:worldgen/run_command": 1},
                    "minecraft:custom_data": {
                        "command": f"function {mob.namespace}:mob/summon/{mob.id}"
                    }
                }
            }
        }
    }
    # data = mob.entity_data.copy()
    # data["id"] = mob.base_entity
    ctx.data[path] = Structure(to_nbt({
        "size":[1,1,1],
        "entities": [
            {
                "nbt": data,
                "blockPos": [0, 0, 0],
                "pos": [0.5, 0.0, 0.5]
            }
        ],
        "blocks": [
            {
                "nbt": {
                    "joint": "rollable",
                    "name": "minecraft:bottom",
                    "pool": "minecraft:empty",
                    "final_state": "minecraft:structure_void",
                    "placement_priority": 0,
                    "selection_priority": 0,
                    "id": "minecraft:jigsaw",
                    "target": "minecraft:bottom"
                },
                "pos": [
                    0,
                    0,
                    0
                ],
                "state": 0
            }
        ],
        "palette": [
            {
                "Properties": {
                    "orientation": "down_south"
                },
                "Name": "minecraft:jigsaw"
            }
        ],
        "DataVersion": 4318
        }))

def register_sounds(key, sounds):
    ctx.assets["genesis"].sound_config.merge(SoundConfig({
        key: {
            "sounds": sounds,
            "subtitle": f"genesis.{key}"
        }
    }))

class classproperty:
    def __init__(self, func):
        self.fget = func
    def __get__(self, instance, owner):
        return self.fget(owner)

def before_all(func):
    func.before_all = True
    return func

def after_all(func):
    func.after_all = True
    return func


def event_decorator(func):
    def decorator(bolt_func):
        def run_it(p):
            func(bolt_func, p)
        run_it.decorator = True
        return run_it
    return decorator

def on_init(order: int = 0):
    @event_decorator
    def decorator(func, mob):
        if "on_init_funcs" in mob.__dict__:
            mob.on_init_funcs = mob.on_init_funcs + [(func, order)]
        else:
            mob.on_init_funcs = [(func, order)]
    return decorator

def on_hurt(order: int = 0):
    @event_decorator
    def decorator(func, mob):
        mob.hurt_detection = {}
        if "on_hurt_funcs" in mob.__dict__:
            mob.on_hurt_funcs = mob.on_hurt_funcs + [(func, order)]
        else:
            mob.on_hurt_funcs = [(func, order)]
    return decorator

def on_death(order: int = 0):
    @event_decorator
    def decorator(func, mob):
        mob.hurt_detection = {}
        if "on_death_funcs" in mob.__dict__:
            mob.on_death_funcs = mob.on_death_funcs + [(func, order)]
        else:
            mob.on_death_funcs = [(func, order)]
    return decorator




class CustomComponents:
    def hurt_detection(mob, component):
        mob.tags.add("genesis.mob.component.hurt_detection")
        mob.attributes.append({"id":"minecraft:max_absorption","base":-3.999999999999999})
        mob.active_effects.append({"id":"minecraft:absorption","duration":-1,"show_particles":False,"show_icon":False})
        mob.enchantments.update({"genesis:mob/component/hurt_detection": 1})

    def hurt_tint(mob, component):
        mob.tags.add("genesis.mob.component.hurt_tint")

    def burn_in_daylight(mob, component):
        if component:
            # mob.tags.add("genesis.mob.component.burn_in_daylight")
            mob.enchantments.update({"genesis:mob/component/burn_in_daylight": 1})

    def enchantments(mob, component):
        pass

    def invisible(mob, component):
        if component:
            mob.tags.add("genesis.mob.component.invisible")
            mob.active_effects.append({"id":"minecraft:invisibility","duration":-1,"show_particles":False,"show_icon":False})
    
    def on_init_funcs(mob, component):
        mob.enchantments.update({"genesis:mob/component/init_tick": 1})
        component.sort(key=itemgetter(1))

        path = f'{mob.namespace}:mob/mob/{mob.id}/on_init'

        function path:
            for func, _ in component:
                func()
        
        append function genesis:mob/component/init/tick:
            execute if entity @s[tag=f"genesis.mob.{mob.id}"] run function path
    
    def on_hurt_funcs(mob, component):
        mob.tags.add("genesis.mob.component.on_hurt_funcs")
        component.sort(key=itemgetter(1))

        path = f'{mob.namespace}:mob/mob/{mob.id}/on_hurt'

        function path:
            for func, _ in component:
                func()
        
        append function genesis:mob/component/hurt_detection/call_on_hurt_funcs:
            execute if entity @s[tag=f"genesis.mob.{mob.id}"] run function path
    
    def on_death_funcs(mob, component):
        mob.tags.add("genesis.mob.component.on_death_funcs")
        component.sort(key=itemgetter(1))

        path = f'{mob.namespace}:mob/mob/{mob.id}/on_death'

        function path:
            for func, _ in component:
                func()
        
        append function genesis:mob/component/hurt_detection/call_on_death_funcs:
            execute if entity @s[tag=f"genesis.mob.{mob.id}"] run function path

    def custom_sounds(mob, component):
        mob.silent = True
        mob.tags.add("genesis.mob.component.custom_sounds")
        if "death" in component:
            append function genesis:mob/component/custom_sounds/death:
                execute if entity @s[tag=f"genesis.mob.{mob.id}"] run playsound component["death"] hostile @a[distance=..16] ~ ~ ~
        if "hurt" in component:
            append function genesis:mob/component/custom_sounds/hurt:
                execute if entity @s[tag=f"genesis.mob.{mob.id}"] run playsound component["hurt"] hostile @a[distance=..16] ~ ~ ~
        if "ambient" in component:
            append function genesis:mob/component/custom_sounds/ambient:
                execute if entity @s[tag=f"genesis.mob.{mob.id}"] run playsound component["ambient"] hostile @a[distance=..16] ~ ~ ~

    def loot_table(mob, component):
        path = f'{mob.namespace}:mob/{mob.id}'
        loot_table path component
        mob.death_loot_table = path

    def name(mob, component):
        key = f'{mob.namespace}.mob.{mob.id}'
        add_translation(key, component)
        mob.custom_name = {"translate":key}

class VanillaComponents:
    def tags(mob, component):
        if len(component) == 0:
            return None
        return ("Tags", list(component))
    
    def equipment(mob, component):
        if len(component.keys()) == 0:
            return None
        return ("equipment", component)
    
    def drop_chances(mob, component):
        if len(component.keys()) == 0:
            return None
        return ("drop_chances", component)
    
    def active_effects(mob, component):
        if len(component) == 0:
            return None
        return ("active_effects", component)
    
    def attributes(mob, component):
        if len(component) == 0:
            return None
        return ("attributes", component)
    
    def is_immune_to_zombification(mob, component):
        return ("IsImmuneToZombification", component)
    
    def can_pick_up_loot(mob, component):
        return ("CanPickUpLoot", component)
    
    def silent(mob, component):
        return ("Silent", component)
    
    def death_loot_table(mob, component):
        return ("DeathLootTable", component)
    
    def custom_name(mob, component):
        return ("CustomName", component)


vanilla_components = []
for k in VanillaComponents.__dict__.keys():
    if not k.startswith("__"):
        vanilla_components.append(k)
component_names = vanilla_components.copy()
for k in CustomComponents.__dict__.keys():
    if not k.startswith("__"):
        component_names.append(k)


class MobMetaclass(type):
    def __new__(mcs, name, bases, namespace):
        cls = super().__new__(mcs, name, bases, namespace)
        is_abstract = 'abstract' in cls.__dict__
        if not is_abstract:
            cls.id = camel_case_to_snake_case(cls.__name__)
            cls.namespace = cls.__module__.split(":")[0]
            cls.init_vanilla_components(cls)
            _, callables = _get_components_and_callables_from_parents(cls)
            _run_callables(cls, callables["before_all"])
            _run_callables(cls, callables["regular"])
            components, _ = _get_components_and_callables_from_parents(cls)
            for k, v in components.items():
                if k not in vanilla_components:
                    component = CustomComponents.__dict__[k]
                    component(cls, v)
            _run_callables(cls, callables["after_all"])
        return cls

class GenesisMob(metaclass=MobMetaclass):
    abstract = True
    def init_vanilla_components(cls):
        cls.tags = set()
        cls.equipment = dict()
        cls.drop_chances = dict()
        cls.attributes = []
        cls.active_effects = []
        cls.enchantments = dict()

    @after_all
    def generate_summon_command(mob):
        function f"{mob.namespace}:mob/summon/{mob.id}":
            summon mob.base_entity ~ ~ ~ mob.entity_data

        add_structure(mob)
        add_template_pool(mob)
    
    @classproperty
    def entity_data(cls):
        cls.tags.add("genesis.mob")
        cls.tags.add(f"genesis.mob.{cls.id}")
        data = {}
        components, _ = _get_components_and_callables_from_parents(cls)
        for k, v in components.items(): 
            if k in vanilla_components:
                component = VanillaComponents.__dict__[k]
                serialised = component(cls, v)
                if serialised is not None:
                    nk, nv = serialised
                    data[nk] = nv
        
        if len(cls.enchantments) > 0:
            data["equipment"]["head"]["components"].update({
                "minecraft:enchantment_glint_override": False,
                "minecraft:enchantments": cls.enchantments
            })
        return data


class TexturedHumanoid(GenesisMob):
    abstract = True
    """
    A humanoid shaped mob which can wear armour. 
    Renders a custom texture by equipped items.
    """

    hurt_detection = {}
    hurt_tint = {}
    can_pick_up_loot = False
    lefthand_extra_item_model = None
    righthand_extra_item_model = None

    def generate_assets(mob):
        texture_id = f"{mob.namespace}:entity/{mob.id}"
        if texture_id not in ctx.assets.textures:
            raise LookupError(f"Missing texture: {texture_id}")
        
        # pants texture & model
        img = ctx.assets.textures[texture_id].image
        img = img.crop((0,0,img.width, img.height//2))
        ctx.assets[f"{mob.namespace}:entity/equipment/humanoid_leggings/_mob/{mob.id}"] = Texture(img)
        ctx.assets[f"{mob.namespace}:_mob/{mob.id}"] = Equipment({
            "layers": {
                "humanoid_leggings": [
                    {
                        "texture": f"{mob.namespace}:_mob/{mob.id}",
                        "dyeable": {
                            "color_when_undyed": 16383998
                        }
                    }
                ]
            }
        })
        
        # arms and head models
        ctx.assets.textures[f"{mob.namespace}:item/_mob/{mob.id}"] = ctx.assets.textures[texture_id]
        for side in ["left","right"]:
            ctx.assets[f"{mob.namespace}:item/_mob/{mob.id}/{side}_arm"] = Model({
                "parent": f"{mob.namespace}:item/_mob/textured_zombie_variant/{side}_arm",
                "textures": {
                    "0": f"{mob.namespace}:item/_mob/{mob.id}"
                }
            })
        ctx.assets[f"{mob.namespace}:item/_mob/{mob.id}/head"] = Model({
            "parent": f"{mob.namespace}:item/_mob/textured_zombie_variant/head",
            "textures": {
                "0": f"{mob.namespace}:item/_mob/{mob.id}"
            }
        })

        righthand_model = {
                            "type": "minecraft:model",
                            "model": f"{mob.namespace}:item/_mob/{mob.id}/right_arm",
                            "tints": [
                                {
                                    "type": "minecraft:dye",
                                    "default": [1,1,1]
                                }
                            ]
                        }
        if mob.righthand_extra_item_model is not None:
            righthand_model = {
                "type": "minecraft:composite",
                "models": [
                    righthand_model,
                    mob.righthand_extra_item_model
                ]
            }

        lefthand_model = {
                            "type": "minecraft:model",
                            "model": f"{mob.namespace}:item/_mob/{mob.id}/left_arm",
                            "tints": [
                                {
                                    "type": "minecraft:dye",
                                    "default": [1,1,1]
                                }
                            ]
                        }
        if mob.lefthand_extra_item_model is not None:
            lefthand_model = {
                "type": "minecraft:composite",
                "models": [
                    lefthand_model,
                    mob.lefthand_extra_item_model
                ]
            }

        ctx.assets[f"{mob.namespace}:_mob/{mob.id}/skin"] = ItemModel({
            "model": {
                "type": "minecraft:select",
                "property": "minecraft:display_context",
                "cases": [
                    {
                        "when": "thirdperson_righthand",
                        "model": righthand_model
                    },
                    {
                        "when": "thirdperson_lefthand",
                        "model": lefthand_model
                    }
                ],
                "fallback": {
                    "type": "minecraft:model",
                    "model": f"{mob.namespace}:item/_mob/{mob.id}/head",
                    "tints": [
                        {
                            "type": "minecraft:dye",
                            "default": [1,1,1]
                        }
                    ]
                }
            }
        })
        skin_item = {
            "id": "minecraft:poisonous_potato",
            "count": 1,
            "components": {
                "minecraft:item_model": f"{mob.namespace}:_mob/{mob.id}/skin"
            }
        }
        pants = {
            "id": "minecraft:poisonous_potato",
            "count": 1,
            "components": {
                "minecraft:equippable": {
                    "slot": "legs",
                    "asset_id": f"{mob.namespace}:_mob/{mob.id}",
                    "equip_sound": {"sound_id":"none"}
                }
            }
        }
        mob.equipment.update({
            "mainhand": deepcopy(skin_item),
            "offhand": deepcopy(skin_item),
            "head": deepcopy(skin_item),
            "legs": pants
        })
        mob.drop_chances.update({
            "mainhand": 0,
            "offhand": 0,
            "head": 0,
            "legs": 0
        })

class TexturedZombieVariant(TexturedHumanoid):
    abstract=True
    """
    A zombie-like mob with a custom texture rendered by equipped items.
    Can only use meelee attacks.
    """

    burn_in_daylight = True

    base_entity = "minecraft:zombie"


class PlayerLike(TexturedHumanoid):
    abstract=True
    """
    A human-shaped mob which holds its arms down.
    Can only use meelee attacks.
    """

    base_entity = "minecraft:piglin_brute"
    invisible = True

    is_immune_to_zombification = True

    custom_sounds = {
        "hurt": "minecraft:entity.enderman.hurt",
        "death": "minecraft:entity.enderman.death",
        "ambient": "minecraft:entity.enderman.ambient"
    }