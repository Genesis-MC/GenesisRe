from contextlib import contextmanager
from genesis:mapping import char_width
from beet import Language
from nbtlib import String, Int, Byte, Double, List, Compound
from mecha import Mecha


mc = ctx.inject(Mecha)


def parse_selector(s: str):
    return mc.parse(s, using='selector')


def add_translation(key: str, value: str):
    lang = ctx.assets.languages.get("genesis:en_us", {data:{}}).data
    lang[key] = value
    ctx.assets.languages["genesis:en_us"] = Language(lang)
    return key


def break_text_into_lines(text: str, trans_base: str, italic = False, color = "gray"):
    out = []
    line_index = 0
    line_length = char_width[text[0]]
    line = text[0]
    for i in range(len(text)-1):
        if (line_length + char_width[text[i+1]]) > 200:
            overflow = ""
            while line[-1] is not ' ':
                overflow = line[-1] + overflow
                line = line[:-1]
            line = line[:-1]

            trans_key1 = f'{trans_base}.{line_index}'
            add_translation(trans_key1, line)
            out.append({"translate":trans_key1,"color":color,"italic":italic})
            line_length = 0
            line_index += 1
            line = overflow

        line_length += char_width[text[i+1]]
        line += text[i+1]
    if line:
        trans_key2 = f'{trans_base}.{line_index}'
        add_translation(trans_key2, line)
        out.append({"translate":trans_key2,"color":color,"italic":italic})
    return out


constants = []
def constant(n):
    global constants
    if n not in constants:
        constants.append(n)
        append function genesis:load:
            scoreboard players set f'#{n}' genesis n
    return f'#{n}'


def texture_path_to_item_model(path: str, is_handheld = False) -> str:
    if not ':item/' in path:
        raise Exception(f'"{path}" is not valid, it has to be in the "item" subfolder')
    truncated_path = path.replace(':item/',':')

    parent = "minecraft:item/generated"
    if is_handheld:
        parent = "minecraft:item/handheld"

    model path {
        "parent": parent,
        "textures": {"layer0": path}
    }

    item_model truncated_path { "model": {
        "type": "minecraft:model",
        "model": path
    }}

    return truncated_path


def camel_case_to_snake_case(s: str):
    out = s[0].lower()
    for c in s[1:]:
        if c.isupper():
            out += '_' + c.lower()
        elif c.islower() or c.isnumeric():
            out += c
        else:
            out += '_'
    while '__' in out:
        out = out.replace('__','_')
    return out

def to_nbt(obj):
    def r(v):
        t = type(v)
        if t == dict:
            o = {}
            for k, dv in v.items():
                o[k] = r(dv)
            return Compound(o)
        if t == list:
            l = []
            for li in v:
                l.append(r(li))
            return List[type(l[0])](l)
        if t == str:
            return String(v)
        if t == int:
            return Int(v)
        if t == float:
            return Double(v)
        if t == bool:
            if v:
                return Byte(1)
            return Byte(0)
        raise RuntimeError(f"Type '{t}' is not supported")
    return r(obj)


def smart_scoreboard_operation(name: str, board: str, operation: str, value: int|tuple[str,str]):
    if isinstance(value, int):
        if operation == '=':
            cmd = f'scoreboard players set {name} {board} {value}'
        elif operation == '+=':
            cmd = f'scoreboard players add {name} {board} {value}'
        elif operation == '-=':
            cmd = f'scoreboard players remove {name} {board} {value}'
        else:
            cmd = f'scoreboard players operation {name} {board} {operation} {constant(value)} genesis'
    else:
        cmd = f'scoreboard players operation {name} {board} {operation} {value[0]} {value[1]}'
    raw (cmd)


registered_schedule_loops = []
def schedule_loop(ticks: int):
    global registered_schedule_loops
    path = f'genesis:tick_{ticks}'
    if path in registered_schedule_loops:
        return path
    append function genesis:load:
        execute function path:
            schedule function path (ticks)
    return path


registered_player_schedule_loops = []
def player_schedule_loop(ticks: int):
    global registered_player_schedule_loops
    path = f'genesis:player/tick_{ticks}'
    if path in registered_player_schedule_loops:
        return path
    append function schedule_loop(ticks):
        as @a at @s function path
    return path


@contextmanager
def hitbox(size: float, selector: str, fix_offset = False):
    visualize_hitboxes = ctx.meta.get("visualize_hitboxes", False)

    if selector.endswith(']'):
        selector = selector[:-1] + ','
    else:
        selector += '['
    if size > 1:
        selector_format = 'dx={d},dy={d},dz={d}]'
        delta = size - 1
        offset = size / 2
        if fix_offset:
            if visualize_hitboxes:
                if function particle_hitbox(size) positioned ~-offset ~-offset ~-offset as parse_selector(selector + selector_format.format(d=delta)) positioned ~offset ~offset ~offset:
                    yield
            else:
                positioned ~-offset ~-offset ~-offset as parse_selector(selector + selector_format.format(d=delta)) positioned ~offset ~offset ~offset:
                    yield
        else:
            if visualize_hitboxes:
                if function particle_hitbox(size) positioned ~-offset ~-offset ~-offset as parse_selector(selector + selector_format.format(d=delta)):
                    yield
            else:
                positioned ~-offset ~-offset ~-offset as parse_selector(selector + selector_format.format(d=delta)):
                    yield
    else:
        first_offset = size / 2
        second_offset = 1 - size
        if fix_offset:
            return_offset = first_offset + second_offset
            if visualize_hitboxes:
                if function particle_hitbox(size) positioned ~-first_offset ~-first_offset ~-first_offset as parse_selector(selector + 'dx=0]') positioned ~-second_offset ~-second_offset ~-second_offset if entity @s[dx=0] positioned ~return_offset ~return_offset ~return_offset:
                    yield
            else:
                positioned ~-first_offset ~-first_offset ~-first_offset as parse_selector(selector + 'dx=0]') positioned ~-second_offset ~-second_offset ~-second_offset if entity @s[dx=0] positioned ~return_offset ~return_offset ~return_offset:
                    yield
        else:
            if visualize_hitboxes:
                if function particle_hitbox(size) positioned ~-first_offset ~-first_offset ~-first_offset as parse_selector(selector + 'dx=0]') positioned ~-second_offset ~-second_offset ~-second_offset if entity @s[dx=0]:
                    yield
            else:
                positioned ~-first_offset ~-first_offset ~-first_offset as parse_selector(selector + 'dx=0]') positioned ~-second_offset ~-second_offset ~-second_offset if entity @s[dx=0]:
                    yield


particle_hitbox_functions = []
def particle_hitbox(size: float, color = (1.0,0.4,0.9)):
    path = f'genesis/debug/hitbox/{size}'
    for c in color:
        path += '_' + str(c)

    if path not in particle_hitbox_functions:
        offset = size / 2
        scaled_offset = int(offset * 20)
        function path:
            for i in range(-scaled_offset, scaled_offset):
                dist = i / 20
                particle dust{scale:.1,'color':(color)} ~dist ~-offset ~-offset
                particle dust{scale:.1,'color':(color)} ~dist ~-offset ~offset
                particle dust{scale:.1,'color':(color)} ~dist ~offset ~-offset
                particle dust{scale:.1,'color':(color)} ~dist ~offset ~offset

                particle dust{scale:.1,'color':(color)} ~-offset ~dist ~-offset
                particle dust{scale:.1,'color':(color)} ~-offset ~dist ~offset
                particle dust{scale:.1,'color':(color)} ~offset ~dist ~-offset
                particle dust{scale:.1,'color':(color)} ~offset ~dist ~offset

                particle dust{scale:.1,'color':(color)} ~-offset ~-offset ~dist
                particle dust{scale:.1,'color':(color)} ~-offset ~offset ~dist
                particle dust{scale:.1,'color':(color)} ~offset ~-offset ~dist
                particle dust{scale:.1,'color':(color)} ~offset ~offset ~dist
            execute return 1
    return path
