from contextlib import contextmanager
from genesis:mapping import char_width
from beet import Language
from nbtlib import String, Int, Byte, Double, List, Compound
from mecha import Mecha


mc = ctx.inject(Mecha)


def parse_selector(s: str):
    return mc.parse(s, using='selector')


def add_translation(key: str, value: str):
    lang = ctx.assets.languages.get("genesis:en_us", {data:{}}).data
    lang[key] = value
    ctx.assets.languages["genesis:en_us"] = Language(lang)
    return key


def break_text_into_lines(text: str, trans_base: str, italic = False, color = "gray"):
    out = []
    line_index = 0
    line_length = char_width[text[0]]
    line = text[0]
    for i in range(len(text)-1):
        if (line_length + char_width[text[i+1]]) > 200:
            overflow = ""
            while line[-1] is not ' ':
                overflow = line[-1] + overflow
                line = line[:-1]
            line = line[:-1]

            trans_key1 = f'{trans_base}.{line_index}'
            add_translation(trans_key1, line)
            out.append({"translate":trans_key1,"color":color,"italic":italic})
            line_length = 0
            line_index += 1
            line = overflow

        line_length += char_width[text[i+1]]
        line += text[i+1]
    if line:
        trans_key2 = f'{trans_base}.{line_index}'
        add_translation(trans_key2, line)
        out.append({"translate":trans_key2,"color":color,"italic":italic})
    return out


constants = []
def constant(n):
    global constants
    if n not in constants:
        constants.append(n)
        append function genesis:load:
            scoreboard players set f'#{n}' genesis n
    return f'#{n}'


def texture_path_to_item_model(path: str, is_handheld = False) -> str:
    if not ':item/' in path:
        raise Exception(f'"{path}" is not valid, it has to be in the "item" subfolder')
    truncated_path = path.replace(':item/',':')

    parent = "minecraft:item/generated"
    if is_handheld:
        parent = "minecraft:item/handheld"

    model path {
        "parent": parent,
        "textures": {"layer0": path}
    }

    item_model truncated_path { "model": {
        "type": "minecraft:model",
        "model": path
    }}

    return truncated_path


def camel_case_to_snake_case(s: str):
    out = s[0].lower()
    for c in s[1:]:
        if c.isupper():
            out += '_' + c.lower()
        elif c.islower() or c.isnumeric():
            out += c
        else:
            out += '_'
    while '__' in out:
        out = out.replace('__','_')
    return out

def to_nbt(obj):
    def r(v):
        t = type(v)
        if t == dict:
            o = {}
            for k, dv in v.items():
                o[k] = r(dv)
            return Compound(o)
        if t == list:
            l = []
            for li in v:
                l.append(r(li))
            return List[type(l[0])](l)
        if t == str:
            return String(v)
        if t == int:
            return Int(v)
        if t == float:
            return Double(v)
        if t == bool:
            if v:
                return Byte(1)
            return Byte(0)
        raise RuntimeError(f"Type '{t}' is not supported")
    return r(obj)


def smart_scoreboard_operation(name: str, board: str, operation: str, value: int|tuple[str,str]):
    if isinstance(value, int):
        if operation == '=':
            cmd = f'scoreboard players set {name} {board} {value}'
        elif operation == '+=':
            cmd = f'scoreboard players add {name} {board} {value}'
        elif operation == '-=':
            cmd = f'scoreboard players remove {name} {board} {value}'
        else:
            cmd = f'scoreboard players operation {name} {board} {operation} {constant(value)} genesis'
    else:
        cmd = f'scoreboard players operation {name} {board} {operation} {value[0]} {value[1]}'
    raw (cmd)


registered_schedule_loops = []
def schedule_loop(ticks: int):
    global registered_schedule_loops
    path = f'genesis:tick_{ticks}'
    if path in registered_schedule_loops:
        return path
    append function genesis:load:
        execute function path:
            schedule function path (ticks)
    registered_schedule_loops.append(path)
    return path


registered_player_schedule_loops = []
def player_schedule_loop(ticks: int):
    global registered_player_schedule_loops
    path = f'genesis:player/tick_{ticks}'
    if path in registered_player_schedule_loops:
        return path
    append function schedule_loop(ticks):
        as @a at @s function path
    registered_player_schedule_loops.append(path)
    return path


@contextmanager
def hitbox(size: float, selector: str, fix_offset = False, overwrite_y = 0): # overwrite y only supports values >= 1
    if selector.endswith(']'):
        selector = selector[:-1] + ','
    else:
        selector += '['
    size_y = size
    if size > 1:
        selector_format = 'dx={d},dy={dy},dz={d}]'
        delta = size - 1
        delta_y = delta
        offset = size / 2
        offset_y = offset
        if overwrite_y:
            offset_y = 0
            delta_y = overwrite_y - 1
            size_y = overwrite_y
        if fix_offset:
            with particle_hitbox([size,size_y,size]):
                positioned ~-offset ~-offset_y ~-offset as parse_selector(selector + selector_format.format(d=delta,dy=delta_y)) positioned ~offset ~offset_y ~offset:
                    yield
        else:
            with particle_hitbox([size,size_y,size]):
                positioned ~-offset ~-offset_y ~-offset as parse_selector(selector + selector_format.format(d=delta,dy=delta_y)):
                    yield
    else:
        first_offset = size / 2
        first_offset_y = first_offset
        second_offset = 1 - size
        second_offset_y = second_offset
        selector_ext = 'dx=0]'
        if overwrite_y:
            selector_ext = f'dy={overwrite_y-1},' + selector_ext
            first_offset_y = 0
            second_offset_y = 0
            size_y = overwrite_y
        if fix_offset:
            return_offset = first_offset + second_offset
            return_offset_y = return_offset
            if overwrite_y:
                return_offset_y = 0
            with particle_hitbox([size,size_y,size]):
                positioned ~-first_offset ~-first_offset_y ~-first_offset as parse_selector(selector + selector_ext) positioned ~-second_offset ~-second_offset_y ~-second_offset if entity @s[dx=0] positioned ~return_offset ~return_offset_y ~return_offset:
                    yield
        else:
            with particle_hitbox([size,size_y,size]):
                positioned ~-first_offset ~-first_offset_y ~-first_offset as parse_selector(selector + selector_ext) positioned ~-second_offset ~-second_offset_y ~-second_offset if entity @s[dx=0]:
                    yield


def clamp(v, min, max):
    if v < min:
        return min
    if v > max:
        return max
    return v


particle_hitbox_functions = []
@contextmanager
def particle_hitbox(size: tuple[float,float,float], color = (1.0,0.4,0.9)):
    visualize_hitboxes = ctx.meta.get("visualize_hitboxes", False)

    if not visualize_hitboxes:
        yield
        return

    path = f'genesis:debug/hitbox/{size[0]}_{size[1]}_{size[2]}'
    for c in color:
        path += '_' + str(c)

    if path not in particle_hitbox_functions:
        resolution = [size[0]/10,size[1]/10,size[2]/10]
        offset = [size[0]/2,size[1]/2,size[2]/2]
        scaled_offset = [int(offset[0]*resolution[0]),int(offset[1]*resolution[1]),int(offset[2]*resolution[2])]
        function path:
            for i in range(-scaled_offset[0], scaled_offset[0]):
                dist_x = i / resolution[0]
                particle dust{scale:(clamp(1/resolution[0],0.01,4)),'color':(color)} ~dist_x ~-offset[1] ~-offset[2]
                particle dust{scale:(clamp(1/resolution[0],0.01,4)),'color':(color)} ~dist_x ~-offset[1] ~offset[2]
                particle dust{scale:(clamp(1/resolution[0],0.01,4)),'color':(color)} ~dist_x ~offset[1] ~-offset[2]
                particle dust{scale:(clamp(1/resolution[0],0.01,4)),'color':(color)} ~dist_x ~offset[1] ~offset[2]

            for i in range(-scaled_offset[1], scaled_offset[1]):
                dist_y = i / resolution[1]
                particle dust{scale:(clamp(1/resolution[1],0.01,4)),'color':(color)} ~-offset[0] ~dist_y ~-offset[2]
                particle dust{scale:(clamp(1/resolution[1],0.01,4)),'color':(color)} ~-offset[0] ~dist_y ~offset[2]
                particle dust{scale:(clamp(1/resolution[1],0.01,4)),'color':(color)} ~offset[0] ~dist_y ~-offset[2]
                particle dust{scale:(clamp(1/resolution[1],0.01,4)),'color':(color)} ~offset[0] ~dist_y ~offset[2]

            for i in range(-scaled_offset[2], scaled_offset[2]):
                dist_z = i / resolution[2]
                particle dust{scale:(clamp(1/resolution[2],0.01,4)),'color':(color)} ~-offset[0] ~-offset[1] ~dist_z
                particle dust{scale:(clamp(1/resolution[2],0.01,4)),'color':(color)} ~-offset[0] ~offset[1] ~dist_z
                particle dust{scale:(clamp(1/resolution[2],0.01,4)),'color':(color)} ~offset[0] ~-offset[1] ~dist_z
                particle dust{scale:(clamp(1/resolution[2],0.01,4)),'color':(color)} ~offset[0] ~offset[1] ~dist_z
            execute return 1
    if function path:
        yield


chance_predicates = []
def chance_predicate(v: float):
    path = f'genesis:utils/chance_{v}'
    global chance_predicates
    if v in chance_predicates:
        return path
    chance_predicates.append(v)
    predicate path {"condition": "minecraft:random_chance", "chance": (v)}
    return path


class ClassPropertyDescriptor(object):
    #https://stackoverflow.com/questions/5189699/how-to-make-a-class-property
    def __init__(self, fget, fset=None):
        self.fget = fget
        self.fset = fset

    def __get__(self, obj, klass=None):
        if klass is None:
            klass = type(obj)
        return self.fget.__get__(obj, klass)()

    def __set__(self, obj, value):
        if not self.fset:
            raise AttributeError("can't set attribute")
        type_ = type(obj)
        return self.fset.__get__(obj, type_)(value)

    def setter(self, func):
        if not isinstance(func, (classmethod, staticmethod)):
            func = classmethod(func)
        self.fset = func
        return self

def classproperty(func):
    if not isinstance(func, (classmethod, staticmethod)):
        func = classmethod(func)

    return ClassPropertyDescriptor(func)