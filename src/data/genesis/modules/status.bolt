from genesis:utils import camel_case_to_snake_case, constant, smart_scoreboard_operation
from beet import Font


added_slots = []
added_slots_remove_next = []
added_categories = []
current_icon = 192


append function genesis:load:
    scoreboard objectives add genesis.status.remove_next dummy
    scoreboard objectives add genesis.status.has_visual_cooldown dummy
    scoreboard objectives add genesis.status.has_status dummy
    scoreboard objectives add genesis.status.has_icon dummy


predicate genesis:status/remove_next {
    "condition": "minecraft:value_check",
    "value": {
        "type": "minecraft:score",
        "target": {
            "type": "minecraft:fixed",
            "name": ".gametime"
        },
        "score": "genesis"
    },
    "range": {
        "min": {
            "type": "minecraft:score",
            "target": "this",
            "score": "genesis.status.remove_next"
        }
    }
}


append function genesis:tick:
    as @e[type=!#genesis:non_living,tag=genesis.status.has_status,predicate=genesis:status/remove_next] function genesis:status/remove_next:
        scoreboard players set @s genesis.status.remove_next 2147483647


append function genesis:player/join:
    scoreboard players set @s genesis.status.remove_next 2147483647


class GenesisStatusMetaclass(type):
    def __new__(mcs, name, bases, namespace):
        cls = super().__new__(mcs, name, bases, namespace)
        if cls.__dict__.get('abstract', False):
            return cls

        cls.id = camel_case_to_snake_case(cls.__name__)
        cls.tag = f'genesis.status.has.{cls.id}'

        is_permanent = getattr(cls, 'permanent', False)
        has_slot = hasattr(cls, 'slot')
        has_icon = hasattr(cls, 'icon')

        #> SET DEFAULTS
        # add slot to category
        if has_slot:
            cls.category = getattr(cls, 'category', []) + [cls.slot]
        # set stuff based on icon
        if has_icon:
            global current_icon
            cls.icon_chr = chr(current_icon)
            current_icon += 1

        #> SET SCOREBOARD VARIABLES
        if has_slot:
            cls.until = f'genesis.status.slot.{cls.slot}.until'
            cls.value = f'genesis.status.slot.{cls.slot}.value'
            cls.max_duration = f'genesis.status.slot.{cls.slot}.max_duration'
        else:
            cls.until = f'genesis.status.unique.{cls.id}.until'
            cls.value = f'genesis.status.unique.{cls.id}.value'
            cls.max_duration = f'genesis.status.unique.{cls.id}.max_duration'

        #> REGISTER SCOREBOARDS
        global added_slots
        append function genesis:load:
            if has_slot:
                if (cls.slot + ';value') not in added_slots:
                    added_slots.append(cls.slot + ';value')
                    scoreboard objectives add (cls.value) dummy
                if (cls.slot + ';until') not in added_slots and not is_permanent:
                    added_slots.append(cls.slot + ';until')
                    scoreboard objectives add (cls.until) dummy
                if (cls.slot + ';max_duration') not in added_slots and not is_permanent and has_icon:
                    added_slots.append(cls.slot + ';max_duration')
                    scoreboard objectives add (cls.max_duration) dummy
            else:
                scoreboard objectives add (cls.value) dummy
                if not is_permanent:
                    scoreboard objectives add (cls.until) dummy
                if has_icon and not is_permanent:
                    scoreboard objectives add (cls.max_duration) dummy

        #> SET UP STUFF FOR TIMING OUT
        if not is_permanent:
            prepend function genesis:status/remove_next:
                if entity @s[tag=(cls.tag)] if score .gametime genesis >= @s (cls.until) function f'genesis:status/remove/{cls.id}'

            global added_slots_remove_next
            append function genesis:status/remove_next:
                if not has_slot:
                    if score @s (cls.until) matches 1.. scoreboard players operation @s genesis.status.remove_next < @s (cls.until)
                elif cls.slot not in added_slots_remove_next:
                    added_slots_remove_next.append(cls.slot)
                    if score @s (cls.until) matches 1.. scoreboard players operation @s genesis.status.remove_next < @s (cls.until)

        #> SET UP APPLY "METHOD"
        def apply(duration: int|tuple[str,str], value: int|tuple[str,str] = 0):
            if has_slot:
                if entity @s[tag=f'genesis.status.category.{cls.slot}'] function f'genesis:status/category/{cls.slot}/remove'
            else:
                if entity @s[tag=(cls.tag)] function f'genesis:status/remove/{cls.id}'

            if not is_permanent:
                if isinstance(duration, int):
                    scoreboard players set @s (cls.until) (duration)
                    if has_icon:
                        scoreboard players set @s (cls.max_duration) (duration)
                else:
                    raw (f'scoreboard players operation @s {cls.until} = {duration[0]} {duration[1]}')
                    if has_icon:
                        scoreboard players operation @s (cls.max_duration) = @s (cls.until)
                scoreboard players operation @s (cls.until) += .gametime genesis
                unless score @s genesis.status.remove_next = @s genesis.status.remove_next scoreboard players set @s genesis.status.remove_next 2147483647
                scoreboard players operation @s genesis.status.remove_next < @s (cls.until)
                scoreboard players add @s genesis.status.has_status 1
                tag @s add genesis.status.has_status

            if isinstance(value, int):
                scoreboard players set @s (cls.value) (value)
            else:
                raw (f'scoreboard players operation @s {cls.value} = {value[0]} {value[1]}')

            tag @s add (cls.tag)

            for category in getattr(cls, 'category', []):
                tag @s add f'genesis.status.category.{category}'

            if has_icon:
                if not is_permanent:
                    scoreboard players add @s genesis.status.has_visual_cooldown 1
                scoreboard players add @s genesis.status.has_icon 1
                function genesis:status/hud/update_icons
                scoreboard players add @s genesis.hud.display 1

            for k in dir(cls):
                v = getattr(cls, k, None)
                if callable(v) and getattr(v, '__on_apply_status__', False):
                    v(cls)
        cls.apply = apply
        if is_permanent:
            def apply2(value: int|tuple[str,str] = 0):
                apply(0, value)
            cls.apply = apply2

        #> SET UP REMOVE "METHOD"
        function f'genesis:status/remove/{cls.id}':
            if has_icon and not is_permanent:
                scoreboard players reset @s (cls.max_duration)
            if not is_permanent:
                scoreboard players reset @s (cls.until)
            scoreboard players reset @s (cls.value)

            tag @s remove (cls.tag)

            for category in getattr(cls, 'category', []):
                function f'genesis:status/category/{category}/refresh'

            if not is_permanent:
                scoreboard players remove @s genesis.status.has_status 1
                if score @s genesis.status.has_status matches 0 tag @s remove genesis.status.has_status
            if has_icon:
                if not is_permanent:
                    scoreboard players remove @s genesis.status.has_visual_cooldown 1
                scoreboard players remove @s genesis.status.has_icon 1
                function genesis:status/hud/update_icons
                scoreboard players remove @s genesis.hud.display 1

            for k in dir(cls):
                v = getattr(cls, k, None)
                if callable(v) and getattr(v, '__on_remove_status__', False):
                    v(cls)

        def remove():
            if entity @s[tag=(cls.tag)] function f'genesis:status/remove/{cls.id}'
        cls.remove = remove

        #> APPEND TO FUNCTION TO REMOVE/REFRESH WHOLE CATEGORY
        global added_categories
        for category in getattr(cls, 'category', []):
            if category not in added_categories:
                added_categories.append(category)
                function f'genesis:status/category/{category}/remove':
                    tag @s remove f'genesis.status.category.{category}'
                function f'genesis:status/category/{category}/refresh':
                    tag @s remove f'genesis.status.category.{category}'

            append function f'genesis:status/category/{category}/remove':
                if entity @s[tag=(cls.tag)] function f'genesis:status/remove/{cls.id}'
            append function f'genesis:status/category/{category}/refresh':
                if entity @s[tag=(cls.tag)] return run tag @s add f'genesis.status.category.{category}'

        #> METHOD TO MODIFY DURATION
        if not is_permanent:
            def modify_duration(operation: str, duration: int|tuple[str,str]):
                scoreboard players operation @s (cls.until) -= .gametime genesis
                smart_scoreboard_operation('@s', cls.until, operation, duration)
                scoreboard players operation @s (cls.until) += .gametime genesis

                scoreboard players set @s genesis.status.remove_next -1 # This makes sure that the remove_next function gets run next tick
            cls.modify_duration = modify_duration

        #> METHOD TO MODIFY VALUE
        def modify_value(operation: str, value: int|tuple[str,str]):
            for k in dir(cls):
                v = getattr(cls, k, None)
                if callable(v) and getattr(v, '__before_value_change_status__', False):
                    v(cls)

            smart_scoreboard_operation('@s', cls.value, operation, value)

            for k in dir(cls):
                v = getattr(cls, k, None)
                if callable(v) and getattr(v, '__after_value_change_status__', False):
                    v(cls)
        cls.modify_value = modify_value

        #> METHOD TO MODIFY MAX DURATION
        if has_icon and not is_permanent:
            def modify_max_duration(operation: str, max_duration: int|tuple[str,str]):
                smart_scoreboard_operation('@s', cls.max_duration, operation, max_duration)
            cls.modify_max_duration = modify_max_duration

        #> ICON STUFF
        if has_icon:
            status_font = ctx.assets.fonts.get('genesis:hud/status', {"data":{"providers":[{
                "type": "bitmap",
                "file": "genesis:font/hud/status_background.png",
                "height": 14,
                "ascent": -27,
                "chars": ["b"]
            }, {
                "type": "bitmap",
                "file": "genesis:font/hud/status_overlay.png",
                "height": 12,
                "ascent": -28,
                "chars": ["0123456789ABC"]
            }, {
                "type": "space",
                "advances": {
                    "|": 1,
                    ":": -14,
                    "#": -15,
                    "+": 92,
                    "-": -92,
                }
            }]}}
            ).data
            status_font['providers'].append({
                "type": "bitmap",
                "file": f'{cls.icon}.png',
                "height": 12,
                "ascent": -28,
                "chars": [cls.icon_chr]
            })
            ctx.assets['genesis:hud/status'] = Font(status_font)

            append function genesis:status/hud/update_icons_for_each:
                #! make icons stack if more are added
                if entity @s[tag=(cls.tag)] function ~/{cls.id}:
                    data modify storage genesis:player self.hud[1][1] append value f'b:{cls.icon_chr}|'
                    data modify storage genesis:player self.hud[1][2] append value "#"

            append function genesis:status/hud/update_cooldown_for_each:
                #! make cooldowns also stack if more are added
                if is_permanent:
                    if entity @s[tag=(cls.tag)] function ~/{cls.id}:
                        data modify storage genesis:player self.hud[2][1] append value f'|0|'
                        data modify storage genesis:player self.hud[2][2] append value "#"
                else:
                    if entity @s[tag=(cls.tag)] function ~/{cls.id}:
                        scoreboard players operation #cooldown_sprite genesis = @s (cls.until)
                        scoreboard players operation #cooldown_sprite genesis -= .gametime genesis
                        scoreboard players operation #cooldown_sprite genesis *= constant(24) genesis
                        store result score #remainder genesis scoreboard players operation #cooldown_sprite genesis /= @s (cls.max_duration)
                        scoreboard players operation #cooldown_sprite genesis /= constant(2) genesis
                        scoreboard players operation #remainder genesis %= constant(2) genesis
                        scoreboard players operation #cooldown_sprite genesis += #remainder genesis

                        if score #cooldown_sprite genesis matches ..0 data modify storage genesis:player self.hud[2][1] append value f'|0|'
                        for i in range(1,12):
                            if score #cooldown_sprite genesis matches (i) data modify storage genesis:player self.hud[2][1] append value f'|{hex(i)[-1].upper()}|'
                        if score #cooldown_sprite genesis matches 12.. data modify storage genesis:player self.hud[2][1] append value f'|C|'
                        data modify storage genesis:player self.hud[2][2] append value "#"
        return cls


class GenesisStatus(metaclass=GenesisStatusMetaclass):
    abstract = True


def on_apply_status(func):
    func.__on_apply_status__ = True
    return func

def on_remove_status(func):
    func.__on_remove_status__ = True
    return func

def before_value_change_status(func):
    func.__before_value_change_status__ = True
    return func

def after_value_change_status(func):
    func.__after_value_change_status__ = True
    return func
