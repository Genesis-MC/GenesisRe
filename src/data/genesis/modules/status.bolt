from genesis:utils import camel_case_to_snake_case, constant, smart_scoreboard_operation, player_schedule_loop
from beet import Font


added_slots = []
added_slots_remove_next = []
added_slots_synced_tick = []
added_categories = []
current_icon = 192


append function genesis:load:
    scoreboard objectives add genesis.status.remove_next dummy
    scoreboard objectives add genesis.status.has_visual_cooldown dummy
    scoreboard objectives add genesis.status.synced_tick.next dummy
    scoreboard objectives add genesis.status.has_status dummy
    scoreboard objectives add genesis.status.has_icon dummy


predicate genesis:status/remove_next {
    "condition": "minecraft:value_check",
    "value": {
        "type": "minecraft:score",
        "target": {
            "type": "minecraft:fixed",
            "name": ".gametime"
        },
        "score": "genesis"
    },
    "range": {
        "min": {
            "type": "minecraft:score",
            "target": "this",
            "score": "genesis.status.remove_next"
        }
    }
}


predicate genesis:status/synced_tick_next {
    "condition": "minecraft:value_check",
    "value": {
        "type": "minecraft:score",
        "target": {
            "type": "minecraft:fixed",
            "name": ".gametime"
        },
        "score": "genesis"
    },
    "range": {
        "min": {
            "type": "minecraft:score",
            "target": "this",
            "score": "genesis.status.synced_tick.next"
        }
    }
}


append function genesis:tick:
    as @e[type=!#genesis:non_living,tag=genesis.status.has_status,predicate=genesis:status/remove_next] function genesis:status/remove_next:
        scoreboard players set @s genesis.status.remove_next 2147483647
    as @e[type=!#genesis:non_living,tag=genesis.status.has_status,predicate=genesis:status/synced_tick_next] at @s function genesis:status/synced_tick_next:
        scoreboard players set @s genesis.status.synced_tick.next 2147483647


append function genesis:player/join:
    scoreboard players set @s genesis.status.remove_next 2147483647
    scoreboard players set @s genesis.status.synced_tick.next 2147483647


class GenesisStatusMetaclass(type):
    def __new__(mcs, name, bases, namespace):
        cls = super().__new__(mcs, name, bases, namespace)
        if cls.__dict__.get('abstract', False):
            return cls

        cls.id = camel_case_to_snake_case(cls.__name__)
        cls.tag = f'genesis.status.has.{cls.id}'

        is_permanent = getattr(cls, 'permanent', False)
        value_names = getattr(cls, 'values', [])
        has_slot = hasattr(cls, 'slot')
        has_icon = hasattr(cls, 'icon')

        #> SET DEFAULTS
        # add slot to category
        if has_slot:
            cls.category = getattr(cls, 'category', []) + [cls.slot]
        # set stuff based on icon
        if has_icon:
            global current_icon
            cls.icon_chr = chr(current_icon)
            current_icon += 1
        # gather callables
        synced_tick_func = None
        scheduled_tick_funcs = {}
        on_apply_funcs = {}
        on_remove_funcs = {}
        before_value_change_funcs = {}
        after_value_change_funcs = {}
        for k in dir(cls):
            v = getattr(cls, k, None)
            if callable(v):
                if getattr(v, '__synced_tick_status__', False):
                    synced_tick_func = v
                elif getattr(v, '__scheduled_tick_status__', False):
                    scheduled_tick_funcs[f'genesis:status/methods/{cls.id}/scheduled_tick_status/{v.__name__}'] = v
                elif getattr(v, '__on_apply_status__', False):
                    on_apply_funcs[f'genesis:status/methods/{cls.id}/on_apply_status/{v.__name__}'] = v
                elif getattr(v, '__on_remove_status__', False):
                    on_remove_funcs[f'genesis:status/methods/{cls.id}/on_remove_status/{v.__name__}'] = v
                elif getattr(v, '__before_value_change_status__', False):
                    before_value_change_funcs[f'genesis:status/methods/{cls.id}/before_value_change_status/{v.__name__}'] = v
                elif getattr(v, '__after_value_change_status__', False):
                    after_value_change_funcs[f'genesis:status/methods/{cls.id}/after_value_change_status/{v.__name__}'] = v


        #> SET SCOREBOARD VARIABLES
        if has_slot:
            cls.until = f'genesis.status.slot.{cls.slot}.until'
            cls.max_duration = f'genesis.status.slot.{cls.slot}.max_duration'
            cls.synced_tick = f'genesis.status.slot.{cls.slot}.synced_tick'
            cls.synced_tick_interval = f'genesis.status.slot.{cls.slot}.synced_tick_interval'
            for idx, name in enumerate(value_names):
                setattr(cls, name, f'genesis.status.slot.{cls.slot}.value.{idx}') # Since the index is used, this creates less scoreboards for slots. The interface should stay 1:1 the same, just the ingame board names are changed.
        else:
            cls.until = f'genesis.status.unique.{cls.id}.until'
            cls.max_duration = f'genesis.status.unique.{cls.id}.max_duration'
            cls.synced_tick = f'genesis.status.unique.{cls.id}.synced_tick'
            cls.synced_tick_interval = f'genesis.status.unique.{cls.id}.synced_tick_interval'
            for name in value_names:
                setattr(cls, name, f'genesis.status.unique.{cls.id}.value.{name}')

        #> REGISTER SCOREBOARDS
        global added_slots
        append function genesis:load:
            if has_slot:
                for name in value_names:
                    if (cls.slot + f';value{name}') not in added_slots:
                        added_slots.append(cls.slot + f';value{name}')
                        scoreboard objectives add (getattr(cls, name)) dummy
                if (cls.slot + ';until') not in added_slots and not is_permanent:
                    added_slots.append(cls.slot + ';until')
                    scoreboard objectives add (cls.until) dummy
                if (cls.slot + ';max_duration') not in added_slots and not is_permanent and has_icon:
                    added_slots.append(cls.slot + ';max_duration')
                    scoreboard objectives add (cls.max_duration) dummy
                if (cls.slot + ';synced_tick') not in added_slots and synced_tick_func != None:
                    added_slots.append(cls.slot + ';synced_tick')
                    scoreboard objectives add (cls.synced_tick) dummy
                    scoreboard objectives add (cls.synced_tick_interval) dummy
            else:
                for name in value_names:
                    scoreboard objectives add (getattr(cls, name)) dummy
                if not is_permanent:
                    scoreboard objectives add (cls.until) dummy
                if has_icon and not is_permanent:
                    scoreboard objectives add (cls.max_duration) dummy
                if synced_tick_func != None:
                    scoreboard objectives add (cls.synced_tick) dummy
                    scoreboard objectives add (cls.synced_tick_interval) dummy

        #> SET UP STUFF FOR TIMING OUT
        if not is_permanent:
            prepend function genesis:status/remove_next:
                if entity @s[tag=(cls.tag)] if score .gametime genesis >= @s (cls.until) function f'genesis:status/remove/{cls.id}'

            global added_slots_remove_next
            append function genesis:status/remove_next:
                if not has_slot:
                    if entity @s[tag=(cls.tag)] scoreboard players operation @s genesis.status.remove_next < @s (cls.until)
                elif cls.slot not in added_slots_remove_next:
                    added_slots_remove_next.append(cls.slot)
                    if score @s (cls.until) matches 1.. scoreboard players operation @s genesis.status.remove_next < @s (cls.until)

        #> SET UP APPLY "METHOD"
        def apply(duration: int|tuple[str,str], **values: int|tuple[str,str]):
            if has_slot:
                if entity @s[tag=f'genesis.status.category.{cls.slot}'] function f'genesis:status/category/{cls.slot}/remove'
            else:
                if entity @s[tag=(cls.tag)] function f'genesis:status/remove/{cls.id}'

            if not is_permanent:
                if isinstance(duration, int):
                    scoreboard players set @s (cls.until) (duration)
                    if has_icon:
                        scoreboard players set @s (cls.max_duration) (duration)
                else:
                    raw (f'scoreboard players operation @s {cls.until} = {duration[0]} {duration[1]}')
                    if has_icon:
                        scoreboard players operation @s (cls.max_duration) = @s (cls.until)
                scoreboard players operation @s (cls.until) += .gametime genesis
                unless score @s genesis.status.remove_next = @s genesis.status.remove_next scoreboard players set @s genesis.status.remove_next 2147483647
                scoreboard players operation @s genesis.status.remove_next < @s (cls.until)
                scoreboard players add @s genesis.status.has_status 1
                tag @s add genesis.status.has_status

            for name, value in values.items():
                if isinstance(value, int):
                    scoreboard players set @s (getattr(cls, name)) (value)
                else:
                    raw (f'scoreboard players operation @s {getattr(cls, name)} = {value[0]} {value[1]}')

            tag @s add (cls.tag)

            for category in getattr(cls, 'category', []):
                tag @s add f'genesis.status.category.{category}'

            if has_icon:
                if not is_permanent:
                    scoreboard players add @s[type=player] genesis.status.has_visual_cooldown 1
                scoreboard players add @s[type=player] genesis.status.has_icon 1
                if entity @s[type=player] function genesis:status/hud/update_icons
                scoreboard players add @s[type=player] genesis.hud.display 1

            for path in on_apply_funcs:
                function path
            if synced_tick_func != None:
                scoreboard players operation @s (cls.synced_tick) = .gametime genesis
                scoreboard players add @s (cls.synced_tick) ((synced_tick_func.__data__['offset'] % synced_tick_func.__data__['interval']) + 1)
                scoreboard players set @s (cls.synced_tick_interval) (synced_tick_func.__data__['interval'])
                unless score @s genesis.status.synced_tick.next = @s genesis.status.synced_tick.next scoreboard players set @s genesis.status.synced_tick.next 2147483647
                scoreboard players operation @s genesis.status.synced_tick.next < @s (cls.synced_tick)

        cls.apply = apply
        if is_permanent:
            def apply2(**values: int|tuple[str,str]):
                apply(0, **values)
            cls.apply = apply2

        #> SET UP SYNCED TICK
        if synced_tick_func != None:
            prepend function genesis:status/synced_tick_next:
                if entity @s[tag=(cls.tag)] if score .gametime genesis >= @s (cls.synced_tick) function f'genesis:status/synced_tick/{cls.id}':
                    store result score #next_synced_tick_check genesis scoreboard players operation @s (cls.synced_tick) += @s (cls.synced_tick_interval)
                    scoreboard players operation @s (cls.synced_tick) = @s (cls.synced_tick_interval)
                    scoreboard players operation @s (cls.synced_tick) += .gametime genesis
                    if score #next_synced_tick_check genesis < .gametime genesis return 0
                    synced_tick_func(cls)

            global added_slots_synced_tick
            append function genesis:status/synced_tick_next:
                if not has_slot:
                    if entity @s[tag=(cls.tag)] scoreboard players operation @s genesis.status.synced_tick.next < @s (cls.synced_tick)
                elif cls.slot not in added_slots_synced_tick:
                    added_slots_synced_tick.append(cls.slot)
                    if score @s (cls.synced_tick) matches 1.. scoreboard players operation @s genesis.status.synced_tick.next < @s (cls.synced_tick)

        #> SET UP REMOVE "METHOD"
        function f'genesis:status/remove/{cls.id}':
            for path in on_remove_funcs:
                function path

            if has_icon and not is_permanent:
                scoreboard players reset @s (cls.max_duration)
            if not is_permanent:
                scoreboard players reset @s (cls.until)
            if synced_tick_func != None:
                scoreboard players reset @s (cls.synced_tick)
                scoreboard players reset @s (cls.synced_tick_interval)
            for name in value_names:
                scoreboard players reset @s (getattr(cls, name))

            tag @s remove (cls.tag)

            for category in getattr(cls, 'category', []):
                function f'genesis:status/category/{category}/refresh'

            if not is_permanent:
                scoreboard players remove @s genesis.status.has_status 1
                if score @s genesis.status.has_status matches 0 tag @s remove genesis.status.has_status
            if has_icon:
                if not is_permanent:
                    scoreboard players remove @s[type=player] genesis.status.has_visual_cooldown 1
                scoreboard players remove @s[type=player] genesis.status.has_icon 1
                if entity @s[type=player] function genesis:status/hud/update_icons
                scoreboard players remove @s[type=player] genesis.hud.display 1

        def remove():
            if entity @s[tag=(cls.tag)] function f'genesis:status/remove/{cls.id}'
        cls.remove = remove

        #> APPEND TO FUNCTION TO REMOVE/REFRESH WHOLE CATEGORY
        global added_categories
        for category in getattr(cls, 'category', []):
            if category not in added_categories:
                added_categories.append(category)
                function f'genesis:status/category/{category}/remove':
                    tag @s remove f'genesis.status.category.{category}'
                function f'genesis:status/category/{category}/refresh':
                    tag @s remove f'genesis.status.category.{category}'

            append function f'genesis:status/category/{category}/remove':
                if entity @s[tag=(cls.tag)] function f'genesis:status/remove/{cls.id}'
            append function f'genesis:status/category/{category}/refresh':
                if entity @s[tag=(cls.tag)] return run tag @s add f'genesis.status.category.{category}'

        #> METHOD TO MODIFY DURATION
        if not is_permanent:
            def modify_duration(operation: str, duration: int|tuple[str,str]):
                scoreboard players operation @s (cls.until) -= .gametime genesis
                smart_scoreboard_operation('@s', cls.until, operation, duration)
                scoreboard players operation @s (cls.until) += .gametime genesis

                scoreboard players set @s genesis.status.remove_next -1 # This makes sure that the remove_next function gets run next tick
            cls.modify_duration = modify_duration

        #> METHOD TO MODIFY VALUE
        def modify_value(name: str, operation: str, value: int|tuple[str,str]):
            for path, func in before_value_change_funcs.items(): #! Add ability to filter here!!
                if func.__data__['only_for'] and name not in func.__data__['only_for']:
                    continue
                function path

            smart_scoreboard_operation('@s', getattr(cls, name), operation, value)

            for path, func in after_value_change_funcs.items(): #! Add ability to filter here!!
                if func.__data__['only_for'] and name not in func.__data__['only_for']:
                    continue
                function path
        cls.modify_value = modify_value

        #> METHOD TO MODIFY MAX DURATION
        if has_icon and not is_permanent:
            def modify_max_duration(operation: str, max_duration: int|tuple[str,str]):
                smart_scoreboard_operation('@s', cls.max_duration, operation, max_duration)
            cls.modify_max_duration = modify_max_duration

        #> ICON STUFF
        if has_icon:
            status_font = ctx.assets.fonts.get('genesis:hud/status', {"data":{"providers":[{
                "type": "bitmap",
                "file": "genesis:font/hud/status_background.png",
                "height": 14,
                "ascent": -27,
                "chars": ["b"]
            }, {
                "type": "bitmap",
                "file": "genesis:font/hud/status_overlay.png",
                "height": 12,
                "ascent": -28,
                "chars": ["0123456789ABC"]
            }, {
                "type": "space",
                "advances": {
                    "|": 1,
                    ":": -14,
                    "#": -15,
                    "+": 92,
                    "-": -92,
                }
            }]}}
            ).data
            status_font['providers'].append({
                "type": "bitmap",
                "file": f'{cls.icon}.png',
                "height": 12,
                "ascent": -28,
                "chars": [cls.icon_chr]
            })
            ctx.assets['genesis:hud/status'] = Font(status_font)

            append function genesis:status/hud/update_icons_for_each:
                #! make icons stack if more are added
                if entity @s[tag=(cls.tag)] function ~/{cls.id}:
                    data modify storage genesis:player self.hud[1][1] append value f'b:{cls.icon_chr}|'
                    data modify storage genesis:player self.hud[1][2] append value "#"

            append function genesis:status/hud/update_cooldown_for_each:
                #! make cooldowns also stack if more are added
                if is_permanent:
                    if entity @s[tag=(cls.tag)] function ~/{cls.id}:
                        data modify storage genesis:player self.hud[2][1] append value f'|0|'
                        data modify storage genesis:player self.hud[2][2] append value "#"
                else:
                    if entity @s[tag=(cls.tag)] function ~/{cls.id}:
                        scoreboard players operation #cooldown_sprite genesis = @s (cls.until)
                        scoreboard players operation #cooldown_sprite genesis -= .gametime genesis
                        scoreboard players operation #cooldown_sprite genesis *= constant(24) genesis
                        store result score #remainder genesis scoreboard players operation #cooldown_sprite genesis /= @s (cls.max_duration)
                        scoreboard players operation #cooldown_sprite genesis /= constant(2) genesis
                        scoreboard players operation #remainder genesis %= constant(2) genesis
                        scoreboard players operation #cooldown_sprite genesis += #remainder genesis

                        if score #cooldown_sprite genesis matches ..0 data modify storage genesis:player self.hud[2][1] append value f'|0|'
                        for i in range(1,12):
                            if score #cooldown_sprite genesis matches (i) data modify storage genesis:player self.hud[2][1] append value f'|{hex(i)[-1].upper()}|'
                        if score #cooldown_sprite genesis matches 12.. data modify storage genesis:player self.hud[2][1] append value f'|C|'
                        data modify storage genesis:player self.hud[2][2] append value "#"

        #> SCHEDULED TICK
        for path, func in scheduled_tick_funcs.items():
            interval = func.__data__['interval']
            append function player_schedule_loop(interval):
                if entity @s[tag=(cls.tag)] function path:
                    func(cls)

        #> REGISTER ALL METHODS
        for path, func in on_apply_funcs.items():
            function path:
                func(cls)
        for path, func in on_remove_funcs.items():
            function path:
                func(cls)
        for path, func in before_value_change_funcs.items():
            function path:
                func(cls)
        for path, func in after_value_change_funcs.items():
            function path:
                func(cls)

        return cls


class GenesisStatus(metaclass=GenesisStatusMetaclass):
    abstract = True
    # values = []
    # """The values this status can store. Access them using Status.name or Status.modify_value('name', ...)"""
    # permanent: bool = False
    # """Set this to True if the status always lasts until manually removed. No duration will be shown in the hud. Improves performance."""
    # icon: str = None
    # """Icon is a texture path to an icon. It needs to be 12x12 and have an invisible pixel in the bottom right corner. Look at other examples"""
    # slot: str = None
    # """Only one status can be in a slot but multiple status' sharing a slot improves performance.
    # Example: 'chest' slot for a status while wearing a chestpiece. Only one item can be equipped as a chestpiece, so they can all be grouped in a single status slot.
    # """
    # category: list[str] = None
    # """Any 'tags' concerning this status. This is versitile and can be used to check for- or remove all status' in the tag at once."""
    # def apply(duration: int|tuple[str,str], **values: int|tuple[str,str] = 0) OR apply(**values: int|tuple[str,str] = 0) if permanent
    # """Run this function to apply the status to @s with the given duration and value. All values can be an integer or a score ('name', 'objective').
    # This can be inlined since it's only a single command.
    # """
    # def remove()
    # """Removes the status.
    # This can be inlined since it's only a single command.
    # """
    # def modify_duration(operation: str, duration: int|tuple[str,str]) ONLY IF NOT permanent
    # """Modify the duration like you would expect. Operation is any scoreboard operation, the duration is an integer or a score."""
    # def modify_value(operation: str, value: int|tuple[str,str])
    # """Modify the value like you would expect. Operation is any scoreboard operation, the value is an integer or a score."""


def on_apply_status(func):
    func.__on_apply_status__ = True
    return func

def on_remove_status(func):
    func.__on_remove_status__ = True
    return func

def before_value_change_status(only_for: list[str] = None):
    def decorator(func):
        func.__data__ = { 'only_for': only_for }
        func.__before_value_change_status__ = True
        return func
    return decorator

def after_value_change_status(only_for: list[str] = None):
    def decorator(func):
        func.__data__ = { 'only_for': only_for }
        func.__after_value_change_status__ = True
        return func
    return decorator

def synced_tick_status(interval, offset = 0):
    def decorator(func):
        func.__data__ = {'interval': interval, 'offset': offset}
        func.__synced_tick_status__ = True
        return func
    return decorator

def scheduled_tick_status(interval: int):
    def decorator(func):
        func.__data__ = {'interval': interval}
        func.__scheduled_tick_status__ = True
        return func
    return decorator
