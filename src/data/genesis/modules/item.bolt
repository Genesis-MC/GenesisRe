from ps_beet_bolt.bolt_item import component_names, Components, _int_hash, _get_mc_components
from genesis:mapping import stat_wrapper_characters, rarity_text_color, categories, rarities, stat_names, category_modifiers, slots, stat_attribute_to_score
from genesis:utils import add_translation, break_text_into_lines, camel_case_to_snake_case
from genesis:tungsten import add_tungsten_components


class GenesisItemMetaclass(type):
    def __new__(mcs, name, bases, namespace):
        cls = super().__new__(mcs, name, bases, namespace)
        if cls.__dict__.get('abstract', False):
            return cls

        if not hasattr(cls, 'base_item'):
            if cls.category[-1] in ['polearm','sword','greatsword','dagger','scythe']:
                cls.base_item = 'stone_sword'
                cls.removed_components = ['attribute_modifiers','max_damage','repairable','tool']
                if not hasattr(cls, 'enchantable'):
                    cls.enchantable = {"value":15}
            elif cls.category[-1] in ['helmet','chestplate','leggings','boots']:
                cls.base_item = f'chainmail_{cls.category[-1]}'
                cls.removed_components = ['attribute_modifiers','max_damage','repairable']
                if not hasattr(cls, 'enchantable'):
                    cls.enchantable = {"value":15}
            else:
                cls.base_item = 'poisonous_potato'
                cls.removed_components = ['food','consumable']

        cls.id = camel_case_to_snake_case(cls.__name__)
        cls.namespace = cls.__module__.split(':')[0]
        cls.hash = _int_hash(f'{cls.namespace}:{cls.id}')

        components = {}
        decorators = []
        for k in dir(cls):
            v = getattr(cls, k, None)
            if k in component_names + ['stats','category','passives']:
                components[k] = v
            elif callable(v) and hasattr(v, 'decorator'):
                decorators.append(v)

        cls.component_proxy = Components(cls.namespace, cls.id, cls.hash, cls.base_item, components)

        if hasattr(cls, 'stats'):
            stats_handler(cls.component_proxy, cls.component_proxy.stats)
        category_handler(cls.component_proxy, cls.component_proxy.category)
        cls.component_proxy.item_name = item_name_transformer(cls.component_proxy, cls.component_proxy.item_name)
        if not hasattr(cls, 'item_model'):
            cls.component_proxy.item_model = item_model_creator(cls.component_proxy)

        for d in decorators:
            d(cls.component_proxy)

        if hasattr(cls, 'passives'):
            passives_handler(cls.component_proxy, cls.component_proxy.passives)
        cls.component_proxy.rarity = rarity_transformer(cls.component_proxy, cls.component_proxy.rarity)

        cls.component_proxy.merge("custom_data", {"bolt-item":{"id":f'{cls.namespace}:{cls.id}',"hash":(cls.hash)}})

        cls.components = _get_mc_components(cls.component_proxy, cls.removed_components)

        add_loot_table(cls)

        return cls


class GenesisItem(metaclass=GenesisItemMetaclass):
    abstract = True


def stats_handler(item: Components, stats_component: tuple[str,dict[str,int]]):
    slot, stats = stats_component

    line = []
    # Go through all stats in order and add lore and attributes if they are included
    for stat_name in stat_names:
        if stat_name not in stats:
            continue

        # Add attribute modifiers
        if stat_name in stat_attribute_to_score:
            amount = (stats[stat_name] / stat_attribute_to_score[stat_name]["ratio"])
            if stat_name == "physical_power" and slot == "mainhand":
                amount -= 1 # Reduce damage attribute by fist damage

            item.merge("attribute_modifiers", [{
                "type": (stat_attribute_to_score[stat_name]["attribute"]),
                "id": f'{item.namespace}:{slot}/{item.id}',
                "amount": (amount),
                "operation": "add_value",
                "slot": (slot),
                "display": {"type": "hidden"},
            }])

        # Add to lore line
        color = "white"
        if stats[stat_name] < 0:
            color = "red"

        value_length = len(str(stats[stat_name]))
        wrapper_chars = stat_wrapper_characters[stat_name]
        post_chars = (value_length * "+") + ((value_length - 1) * ("," + wrapper_chars["mid"])) + ("," + wrapper_chars["post"])
        line += [{"text":wrapper_chars["pre"],"font":"genesis:stat","color":"white","italic":false},{"text":str(stats[stat_name]),"font":"genesis:stat","color":(color)},{"text":(post_chars),"font":"genesis:stat"}]

    item.lore = [line,""] + item.get('lore', [])

    # Add tungsten components
    add_tungsten_components(item, slot)
    item.max_stack_size = 1

    # Add stats to custom data
    item.merge("custom_data", {"genesis": {"stats": {(slot): (stats)}}})


def category_handler(item: Components, category: list[str]):
    category_modifier = None
    if len(category) > 1:
        category_modifier = category[-2]
        if category_modifier == None:
            del category[-2]
        elif category_modifier not in category_modifiers:
            raise Exception(f'"{category_modifier}" is not a valid category modifier')
    main_category = category[-1]
    if main_category not in categories:
        raise Exception(f'Category "{main_category}" is not a valid category')

    line = [
        {"text":"","italic":false},
        {"text":"A","font":"genesis:icon","color":"white"},
        {"translate":f'rarity.genesis.{item.rarity}',"color":rarity_text_color[item.rarity]},
        " ",
    ]
    if category_modifier != None:
        line += [{"translate":f'category_modifier.genesis.{category_modifier}',"color":rarity_text_color[item.rarity]}," "]
    line.append({"translate":f'category.genesis.{main_category}',"color":rarity_text_color[item.rarity]})
    item.lore = [line] + item.get("lore", [])

    item.merge("custom_data", {"genesis": {"categories": (category)}})


def rarity_transformer(item: Components, rarity: str):
    if rarity in ["legendary","mythical","transcendent"]:
        return "epic"
    return rarity


def item_name_transformer(item: Components, item_name: tuple[str,dict|None]):
    trans_string = f'item.{item.namespace}.{item.id}'
    add_translation(trans_string, item_name[0])
    return {"translate":trans_string} | item_name[1]


def item_model_creator(item: Components):
    category = item.category[-1]
    parent = "minecraft:item/generated"
    if category in ['sword','tool']:
        parent = "minecraft:item/handheld"
    elif category in ['polearm','greatsword','dagger','scythe']:
        parent = f'genesis:item/template/{category}'

    path = f'genesis:item/{category}/{item.id}'
    truncated_path = f'genesis:{category}/{item.id}'

    model path {
        "parent": (parent),
        "textures": {"layer0": (path)}
    }

    item_model truncated_path {"model": {
        "type": "minecraft:model",
        "model": (path)
    }}

    return truncated_path


def passives_handler(item: Components, passives: list[dict[str,str]]):
    pre_line = []
    for passive in passives:
        passive_name_id = camel_case_to_snake_case(passive["name"])
        trans_key = f'item.{item.namespace}.{item.id}.{passive_name_id}'
        add_translation(trans_key, passive["name"])
        item.merge(
            "lore",
            pre_line +
            [
                [{"text":"‚ùÇ","color":rarity_text_color["transcendent"],"italic":false}," ",{"translate":(trans_key),"color":"gold"}],
                {"translate":"text.genesis.passive_ability","color":"dark_gray"},
            ] +
            break_text_into_lines(
                passive["description"],
                f'item.{item.namespace}.{item.id}.{passive_name_id}'
            )
        )
        pre_line = [""]


def add_loot_table(item):
    path = f'{item.namespace}:item/{item.category[-1]}/{item.id}'
    loot_table path {
        "pools": [{"rolls": 1,"entries": [{
            "type": "minecraft:item",
            "name": f'minecraft:{item.base_item}',
            "functions": [{"function": "minecraft:set_components","components": item.components}]
        }]}]
    }
    item.loot_table = path
    return item
